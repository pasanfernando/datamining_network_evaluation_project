import matplotlib.pyplot as plt
from operator import itemgetter
from collections import OrderedDict
import numpy as np
__author__ = 'Pasan Fernando'

# plotting the ROC curve or precision recall curve
# specify the curve type correctly

# Building the uberon term: name dictionary
# UberonID : name
ubdic ={}

# The unames.txt is generated by a separate code
ubfile = open('unames.txt', 'r')

for line in ubfile:
    if line != '\n' or 'uberon_id' not in line:
        b = line.strip().split(' ')
        uid = b[0].lower().replace(':','_')
        ubdic[uid]= b[1].lower()

########################################################################################
def ROCplotter(rocdic,func_name, curve_type):
    # getting the uberon name
    func_name = ubdic[func_name]

    if curve_type == 'roc':
        title = 'ROC curve'
        xlab = 'False positive rate'
        ylab = 'True positive rate'

    elif curve_type == 'precision_recall':
        title = 'Precision-recall curve'
        xlab = 'Recall'
        ylab = 'Precision'

    x=[]
    y=[]
    rocdic = OrderedDict(sorted(rocdic.items(), key=lambda t: t[1]))
    for i in rocdic:
        xy = rocdic[i]
        x.append(xy[0])
        y.append(xy[1])
    #print x
    #print y
    plt.title(title+' for '+func_name)
    plt.xlabel(xlab)
    plt.ylabel(ylab)
    plt.plot(x, y)
    #plt.show()
    # saving the figure
    plt.savefig('single_function/'+func_name+title+'.jpg')
    # closing the figure
    plt.close()
    #calculating the area under the curve
    auc = np.trapz(y, x)
    print 'area under the curve is:',auc

    return auc

def metric_plotter(hash1,metric_name,func_name):
    x=[]
    y=[]

    # getting the uberon name
    func_name = ubdic[func_name]
    hash1 = OrderedDict(sorted(hash1.items(), key=lambda t: t[0]))

    for i in hash1:
        x.append(i)
        y.append(hash1[i])

    #print x
    #print y
    plt.plot(x, y)
    plt.title(metric_name+' vs threshold plot for '+func_name)
    plt.xlabel('Threshold')
    plt.ylabel(metric_name)
    #plt.show()
    plt.savefig('single_function/'+func_name+metric_name+'plot.jpg')
    plt.close()

    return

#method to plot all ROC curves or precision-recall curves in the same plot

def general_ROCplotter(genrocdic, curve_type):

    if curve_type == 'roc':
        title = 'ROC curves'
        xlab = 'False positive rate'
        ylab = 'True positive rate'


    elif curve_type == 'precision_recall':
        title = 'Precision-recall curves'
        xlab = 'Recall'
        ylab = 'Precision'


    plt.title(title+' for multiple functions')
    plt.xlabel(xlab)
    plt.ylabel(ylab)
    plt.ylim(0,1.1)

    for i in genrocdic:

        func_name = ubdic[i]

        x=[]
        y=[]
        rocdic = genrocdic[i]
        rocdic = OrderedDict(sorted(rocdic.items(), key=lambda t: t[1]))
        for i in rocdic:
            xy = rocdic[i]
            x.append(xy[0])
            y.append(xy[1])
        #print x
        #print y

        plt.plot(x, y, label=func_name)
        #plt.show()

        # calculating the area under the curve
        auc = np.trapz(y, x)
        print 'area under the curve is:',auc

        # saving the figure
    if curve_type == 'roc':
        plt.legend(loc=4)






    plt.savefig('gen_'+title+'.jpg')
    # closing the figure
    plt.close()

    return